# 拡張の宣言

## 拡張の概要

* Swiftではすでに存在するクラス、構造体、列挙型、およびプロトコルに新しい機能を追加することができる
* この仕組を拡張（extension）、またはエクステンションと呼ぶ

* 拡張定義には、以下の項目に関する新しい定義を記述することができる
 * 計算型のインスタンスプロパティ、計算型のタイププロパティ
 * インスタンスメソッド、タイプメソッド
 * イニシャライザ
 * 添字付け
 * ネスト型定義（型はその拡張定義内で使用する）

 * 拡張定義を使って、そのクラスや構造体をあるプロトコロに適合させることが可能
 
 * 追加できないのは格納がたのインスタンスプロパティ、格納型のタイププロパティ、プロパティオブザーバ
 * すでにそのクラス、または他の拡張記述で定義されている内容を上書き定義することはできない

 ```
 extention 型名 : プロトコル列 {
   イニシャライザ定義
   計算型プロパティ定義
   メソッド定義
   その他おｎ定義 // 型定義、添字付け定義など
 }
 // 書く定義の個数、順序は自由
 ```

## システムの既存の型に対する拡張定義の例

* 拡張定義は通常はクラス、構造体、または列挙型に対して適用するが、Int型やDouble型などにも適用可能

* String型に対してその長さ（文字数）を返す計算型プロパティlengthを定義する

```
extention String {
  var length: Int {
    return self.characters.count // インスタンス自体はselfで表す
  }
}
```

```
let overlord = "オーハu{3099}ーロートu{3099}" // 濁点を合成
print(overlord, overlord.length} // "オーバーロード 7"と表示
```

* 次の例：Coco環境で使われる、長方形領域を表す構造体CGRectにイニシャライザとメソッド、および添字付けを定義する

```
本書を参照
```

## 拡張定義とイニシャライザ

* 値型の定義にイニシャライザの定義がなく、既定イニシャライザ、または全項目イニシャライザを使っているとする
* この型に対して拡張定義でイニシャライザを追加できるが、既定イニシャライザ、全項目イニシャライザも利用し続けることができる

* これはデータ型の本質的に重要な機能は本体部分で定義されていると考えると理解できる
* 拡張定義は基本追加されたものだから本質的な部分を覆い隠すことはない

* クラスに対する拡張定義には、指定イニシャライザを記述することはできない
* 簡易イニシャライザの記述は可能
* デイニシャライザを拡張定義に含めることはできない
* これらもつまり、本質的な機能が本体部分に定義されているためと考える事ができる

## 拡張定義と継承に関する注意

* あるクラスに対して拡張定義を追加した場合、その定義はサブクラスにも継承される
* ただし、拡張定義中の記述はfinalが付けられたものとして扱われる
* つまりスーパークラスの拡張定義の記述はサブクラスで上書き:w

* また、スーパークラスの定義を、サブクラスの拡張定義で上書きすることはできない
* 従い、クラスの規模が大きくなった時に、拡張定義を使って複数のファイルに記述を分割することは可能だが、サブクラスで上書きできなくなるというデメリットについては把握しておく必要がある


# 11.3 プロトコル拡張

## 規定実装の利用に関する注意

* 先の例ではプロトコルの既定実装として用意されていたメソッドtoString()を、プロトコル採用した構造体のプロパティdescriptionの定義から呼び出していた

```
extention Date {
  func toString() -> String {
    return (self as DateType).toString() + ", "
        + (self as TimeType).toString()
  }
}
```

* この定義は実行すると動作するが条件がある
* プロトコルDateType、TimeTypeのどちらもプロトコルに同じ名前のメソッドtoString()を含めていないといけない
* どちらか、あるいは片方がプロトコルに含めている場合、再帰的にtoString()を呼び出すため異常終了する
* 既定実装はクラス定義とは異なり、基本的には宣言であり、動的な側面をほとんど持っていない
* クラス継承のように動的に動作するのものではないということを理解して利用する

* それぞれに異なるデータ型に対して共通に動作可能な記述を行うためには、型パラメータを用いSwiftのジェネリクス機能を活用してプロトコルを記述する必要がある
