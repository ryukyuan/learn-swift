# 13 クロージャ

## 13.1 クロージャの宣言

### クロージャの複雑な型宣言

* クロージャに対してオプショナル型の変数を定義するとしたら、型はどのように宣言するか？

```
var cp1: (Int, Int) -> Dobule!
```

* 引数がInt型２つでDobule型のオプショナル型を返すクロージャという意味
* 変数cp1自体はオプショナル型ではない
* 変数をオプショナル型にするには次のように記述する

```
var cp2: ((Int, Int) -> Dobule)!
```

* クロージャはインスタンスのため配列に格納することができる

```
var ca3 = [(Int, Int) -> Dobule]() // エラーになる
```

* 現在、この書き方はエラーになるそこでtypealiasを使うことで問題なくコンパイル可能になる

```
typealias MyClosure = (Int, Int) -> Dobule
var ca3 = [MyClosure]()
```


## 13.2 変数のキャプチャ

### キャプチャとは

* クロージャが関数と違うのはその使い方
* プログラムの実行中にクロージャのインスタンスを作り出し定数や変数に代入したり、メソッドの引数として渡したりすることでプログラムの振る舞いを動的に変更することができる

* クロージャは無名関数と呼ばれることもあるが常に同じ機能のインスタンスが作られるわけではない
* インスタンスが生成される際、クロージャの外側にある変数の値を取り込んでインスタンスの一部とし、インスタンスが呼び出される時にはいつでも値を取り出して使うことができる
* これをキャプチャと呼ぶ

* クロージャが生成される時点でクロージャ式から参照できる定数や変数の集合を、コンテキスト（文脈）と呼ぶ
* キャプチャの機能を活用することで１つのクロージャ式から、その時々のコンテキストを反映したインスタンスを生成することができる

+ グローバル変数は、クロージャの内部からむ変数自体に直接アクセスできる。クロージャの内部から変数の値を変更することができる。
+ クロージャ式を含むコードブロック内で参照可能なローカル変数は、普通にローカル変数として存在している間はクロージャ内からも参照可能で、共通の値が参照、更新できる。コードブロックの実行が終わり、ローカル変数が消滅したあとでもクロージャが使われている場合、クロージャの中からは、元のローカル変数が存在し続きているかのように参照、更新が可能です。
 + 2-a 同じコードブロックでも、いったん実行が終わり、再び実行した時のローカル変数は以前のローカル変数とは別の変数となるため、それらの間で値が共有されることはない。
 + 2-b あるコードブロック内で複数個のクロージャが同時に生成され、それらが同じローカル変数を参照すると、変数の値は共有される。コードブロックの実行が終わり、元のローカル変数が消滅した後でもクロージャが使われている場合ｍそれらのクロージャの中からは、元のローカル変数が存在し続けているように見え、参照、更新はもちろん、クロージャ間で値の共有ができる。
 + 2-c クロージャが、クラスのインスタンスなどの参照型の値を持つローカル変数をキャプチャした場合、その値は強い参照で保持される。クロージャが解放されると同時に、その値への強い参照もなくなる。

### クロージャが個別にローカル変数をキャプチャする場合

* 2-a, 2-b, 2-cの振る舞いについての例

```
var globalCount = 0

// ()->Int という型を持つクロージャのインスタンスを作って返す関数
func marker(a:Int, _ b:Int) -> () -> Int {
    var localvar = a
    return { () -> Int in // クロージャ式。型宣言は省略可能。
        globalCount++     // globalCountは参照されるだけ
        localvar += b     // localvar, b がキャプチャされる
        return localvar
     }
}
```

```
var m1 = marker(10, 1)
print("m1() = \(m1()), globalCount = \(globalCount)")
print("m1() = \(m1()), globalCount = \(globalCount)")
globalCount = 1000
print("m1() = \(m1()), globalCount = \(globalCount)")
var m2 = maker(50, 2)
print("m2() = \(m2()), globalCount = \(globalCount)")
print("m1() = \(m1()), globalCount = \(globalCount)")
print("m2() = \(m2()), globalCount = \(globalCount)")
```

```
m1() = 11, globalCount = 1 // localvar + 1, globalCount + 1
m1() = 12, globalCount = 2 // localvar + 1, globalCount + 1
m1() = 13, globalCount = 1001 // localvar + 1, globalCount(1000) + 1
m2() = 52, globalCount = 1002 // globalCount（グローバル変数）は共有
m1() = 14, globalCoubt = 1003
m2() = 54, globalCoubt = 1004
```

## 13.3 クロージャの使い方と記法

### 引数リストの省略

* Swiftコンパイラは、クロージャ式がどのように利用されているかという情報から、そのクロージャの型に関する推論を行う
* この情報を利用して、クロージャの型宣言を省略することが可能

* 省略の例

```
var clos : (Int, Int) -> String = { (a:Int, bInt) -> String in return "(\(a)/\(b)" }
```

* 変数closは方が明確に定義されているのでクロージャ側で同じ定義をする必要はない
* 引数リストの型が分かっているから、後は識別子の名前がわかればよいだけ
* 文が１つしかないため、returnは書いても同じ

```
cols = { a,b -> String in "\(a)/\(b)" }
```

* 返り値の型もわかっているので省略できる

```
cals = { a, b in "\(a)/\(b)" }
```

* もし、引数のうちいずれかがクロージャで使われなければワイルドカード（_）を置くこともできる

```
cals = ( _, b in "\(b)" }
```

### 引数リスト自体の省略

* シェルスクリプトのように、$0, $1という記法で何番目の仮引数かを表すことができる

```
cols = { "\($a)/\($1)" }
```

