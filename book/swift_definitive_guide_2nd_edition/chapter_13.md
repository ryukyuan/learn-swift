# 13 クロージャ

## 13.1 クロージャの宣言

### クロージャの複雑な型宣言

* クロージャに対してオプショナル型の変数を定義するとしたら、型はどのように宣言するか？

```
var cp1: (Int, Int) -> Dobule!
```

* 引数がInt型２つでDobule型のオプショナル型を返すクロージャという意味
* 変数cp1自体はオプショナル型ではない
* 変数をオプショナル型にするには次のように記述する

```
var cp2: ((Int, Int) -> Dobule)!
```

* クロージャはインスタンスのため配列に格納することができる

```
var ca3 = [(Int, Int) -> Dobule]() // エラーになる
```

* 現在、この書き方はエラーになるそこでtypealiasを使うことで問題なくコンパイル可能になる

```
typealias MyClosure = (Int, Int) -> Dobule
var ca3 = [MyClosure]()
```


## 13.2 変数のキャプチャ

### キャプチャとは

* クロージャが関数と違うのはその使い方
* プログラムの実行中にクロージャのインスタンスを作り出し定数や変数に代入したり、メソッドの引数として渡したりすることでプログラムの振る舞いを動的に変更することができる

* クロージャは無名関数と呼ばれることもあるが常に同じ機能のインスタンスが作られるわけではない
* インスタンスが生成される際、クロージャの外側にある変数の値を取り込んでインスタンスの一部とし、インスタンスが呼び出される時にはいつでも値を取り出して使うことができる
* これをキャプチャと呼ぶ

* クロージャが生成される時点でクロージャ式から参照できる定数や変数の集合を、コンテキスト（文脈）と呼ぶ
* キャプチャの機能を活用することで１つのクロージャ式から、その時々のコンテキストを反映したインスタンスを生成することができる

+ グローバル変数は、クロージャの内部からむ変数自体に直接アクセスできる。クロージャの内部から変数の値を変更することができる。
+ クロージャ式を含むコードブロック内で参照可能なローカル変数は、普通にローカル変数として存在している間はクロージャ内からも参照可能で、共通の値が参照、更新できる。コードブロックの実行が終わり、ローカル変数が消滅したあとでもクロージャが使われている場合、クロージャの中からは、元のローカル変数が存在し続きているかのように参照、更新が可能です。
 + 2-a 同じコードブロックでも、いったん実行が終わり、再び実行した時のローカル変数は以前のローカル変数とは別の変数となるため、それらの間で値が共有されることはない。
 + 2-b あるコードブロック内で複数個のクロージャが同時に生成され、それらが同じローカル変数を参照すると、変数の値は共有される。コードブロックの実行が終わり、元のローカル変数が消滅した後でもクロージャが使われている場合ｍそれらのクロージャの中からは、元のローカル変数が存在し続けているように見え、参照、更新はもちろん、クロージャ間で値の共有ができる。
 + 2-c クロージャが、クラスのインスタンスなどの参照型の値を持つローカル変数をキャプチャした場合、その値は強い参照で保持される。クロージャが解放されると同時に、その値への強い参照もなくなる。

### クロージャが個別にローカル変数をキャプチャする場合

* 2-a, 2-b, 2-cの振る舞いについての例

```
var globalCount = 0

// ()->Int という型を持つクロージャのインスタンスを作って返す関数
func marker(a:Int, _ b:Int) -> () -> Int {
    var localvar = a
    return { () -> Int in // クロージャ式。型宣言は省略可能。
        globalCount++     // globalCountは参照されるだけ
        localvar += b     // localvar, b がキャプチャされる
        return localvar
     }
}
```

```
var m1 = marker(10, 1)
print("m1() = \(m1()), globalCount = \(globalCount)")
print("m1() = \(m1()), globalCount = \(globalCount)")
globalCount = 1000
print("m1() = \(m1()), globalCount = \(globalCount)")
var m2 = maker(50, 2)
print("m2() = \(m2()), globalCount = \(globalCount)")
print("m1() = \(m1()), globalCount = \(globalCount)")
print("m2() = \(m2()), globalCount = \(globalCount)")
```

```
m1() = 11, globalCount = 1 // localvar + 1, globalCount + 1
m1() = 12, globalCount = 2 // localvar + 1, globalCount + 1
m1() = 13, globalCount = 1001 // localvar + 1, globalCount(1000) + 1
m2() = 52, globalCount = 1002 // globalCount（グローバル変数）は共有
m1() = 14, globalCoubt = 1003
m2() = 54, globalCoubt = 1004
```

## 13.3 クロージャの使い方と記法

### 引数リストの省略

* Swiftコンパイラは、クロージャ式がどのように利用されているかという情報から、そのクロージャの型に関する推論を行う
* この情報を利用して、クロージャの型宣言を省略することが可能

* 省略の例

```
var clos : (Int, Int) -> String = { (a:Int, bInt) -> String in return "(\(a)/\(b)" }
```

* 変数closは型が明確に定義されているのでクロージャ側で同じ定義をする必要はない
* 引数リストの型が分かっているから、後は識別子の名前がわかればよいだけ
* 文が１つしかないため、returnは書いても同じ

```
cols = { a,b -> String in "\(a)/\(b)" }
```

* 返り値の型もわかっているので省略できる

```
clos = { a, b in "\(a)/\(b)" }
```

* もし、引数のうちいずれかがクロージャで使われなければワイルドカード（_）を置くこともできる

```
clos = { _, b in "\(b)" }
```

### 引数リスト自体の省略

* シェルスクリプトのように、$0, $1という記法で何番目の仮引数かを表すことができる

```
cols = { "\($0)/\($1)" }
```

### 配列要素に対する操作

* 配列の各要素に次々にクロージャを適用し、その結果を新たな配列路して返すメソッドにmapがある
* Int型の配列adtの各要素を文字列に直し、新しい配列を作るには次のようにする

```
let dat = [2, 80, 45, 13]
let str = dat.map{ "\($0)" } // ["2", "80", "45", "13"] が返る
```

* さらに、配列datから10以上のデータを取り出して、昇順に並び替えた後で各項目を文字列に変換するという処理は次のようになる

```
let str = dat.filter{ $0 >= 10}.sort( < ).map{ "\($0)" }
```

---

* 配列の各要素に順番にクロージャを適用していき、最終的に１つの値を得るメソッドとしてreduceがある
* 1から10までの整数が格納された配列に対して和を求めるには次のようにする

```
let numbers = [Int](1...10)
let sum = numbers.reduce(0) { $0 + $1 } // 和を求めるため、初期値は0、結果は55
// $0が直前までの値、$1が配列の要素
```

* SequenceTypeプロトコルのreduceメソッドはreduce(_:combine:)という形で第２引数にキーワードを持っているので、接尾クロージャ以外の書き方をする場合にはキーワードが必要

```
let sum = numbers.reduce(0, combine:+) // このようにも記述できる
```

### インスタンス列を使ったプログラミングスタイル

* 配列や集合など、SequenceTypeプロトコルに適合した型に対しては、配列の列に対する操作をパイプラインのように結合して、全体としてより複雑な処理を実現することができる
* ループを作ってアルゴリズムを記述するよりも見通しよく機能を実現することができる

```
func filter(@noescape _: (T) throws -> Bool) rethrows -> [T]

// selftの持つ要素に引数のクロージャを適用して、trueを返す要素だけを取り出して新しい配列として返す
```

```
func map<U>(@noescapce _: (T) throws -> U) rethrows -> [U]

// selftの持つ要素に引数のクロージャを適用して、U型のデータを生成し、これらを新しい配列として返す
```

```
func sort(@noescapce _: (T, T) -> Bool) ->  [T]

// T型の要素間で大小比較をするクロージャを引数として、selfの持つ要素を並べ直してできた新しい配列を返す
```

```
func sort() ->  [T]

// 要素の型TがComparableに適合する場合、この形式が利用できる
```

```
func reduce<U>(_: U, @noescape combine: (U, T) throws -> U) rethrows -> U

// 第1引数を初期値とし、その値とselfの第1要素にクロージャを適用して新しい値を作る
// 次にその値について題2要素以降、同様に操作を繰り返し、最後に得られた値を返す
```

* 引数のクロージャに@noescapeという属性がつけられているが、引数のクロージャが関数呼び出しの間しか使われていないことを表す
* エラーを投げるクロージャを引数に指定する場合はtry演算子を使いエラーを補足する手段を用意する












