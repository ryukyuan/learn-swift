# 10章 プロトコル

## 10.2 プロトコル型

### 型としてのプロtコル

* プロトコルはプログラム内で型として使える

```
func printNames(list:[Personal]) {
  for p in list {
    print(p.name + ": " + p.saySomething())
  }
}
```

* プロトコルPersonalに適合するインスタンスを要素とする配列listを引数として、内容の一覧を表示する

* ただし全てのプロトコルが方して使えるわけではない
* typealiasによる付属型の指定やSelfを使って宣言されたプロトコルは型として使えない

### プロトコロの継承

* 新しいプロトコロを宣言する際に別のプロトコルを軽装することができる

```
enum Sex { case Male, Female } // 性別を表す列挙型
protocol HealthInfo : Personal { // プロトコルを継承する
  var weight: Double { get set }  // 読み書き可能なプロパティ
  var height: Double { get set }
  var sex: Sex? { get }
}
```

* プロトコルは、必要に応じて複数個を採用してクラスや構造体を定義できる
* ただし、複数個のプロトコルで同盟のプロパティが異なる型で定義されている場合など、同時に採用できないプロトコルもある

### プロトコルの合成

* 複数のプロトコルで宣言しているインタフェースを和集合のように合わせ持つプロトコルを考えることができます

* 2つのプロトコルのインタフェースを持つ新しいプロトコル
```
protocol NewProtocol : プロトコル1, プロトコル2 {}
```

* 複数のプロトコルの和集合としての型を指定する方法
```
protocol<プロトコル1, プロトコル2>
```

* 以下の2つの記述は同じ意味になる
```
var teller: NewProtocol
var teller: protocol<プロトコル1, プロトコル2>
```

* ただしprotocol<>を使う記法はその箇所で一時的にのみ仕様する記法
* 頻繁に使う型であれば名前のついたプロトコルとして定義したほうがよい
* またクラスや構造体の宣言の先頭にも記述できない



