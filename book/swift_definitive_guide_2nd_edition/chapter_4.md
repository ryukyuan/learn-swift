
# ４章
## 4.1 オプショナル型

### オプショナル型とnil

* 扱うべき値が存在しないことを表すために、nilという特別な値を用意している
* 指し示すべき意味のあるオブジェクトが存在しないことを意味する
* 通常のInt型は値を持つが特殊な場合にnilを値として持つ場合はInt型ではなく、Int?という型で扱う
* これをオプショナル（optional）Int型と呼ぶ

```
var a : Int = 0
var b : Int? = 10
b = nil // 代入可能
a = nil // エラーとなる
```

* 他の型についても同様にオプショナル型を利用できる
* オプショナル型を使うことでNullPointerExceptionを避けることを期待している
* オプショナル型は、データ型のイニシャライザの返り値にも使われる

文字列を引数とするイニシャライザの例

```
let olympic = "2020"
var year : Int? = Int(olympic) // 2020が返される
var city : Int? = Int("Tokyo") // 整数と評価されず、nilが返される
```

パラーメータ付き型指定を使ったオプショナル型
```
var year : Optional<Int> = Int("2020")
```

### オプショナル型の値を開示する

* オプショナル型からデータを取り出すことを開示（アンラップ：unwrap）と呼ぶ
* 開示のためには明示的に「!」という記号を使う（開示指定とよぶ）

```
let year : Int? = Int("2020")
var remain : Int = year! - 2016 // 開示が必要
```

* オプショナル型の値の変数がnilの場合はコンパイルはできるが実行時エラーとなる（NullPointerException）

### 条件判定とオプショナル型

* 開示して値を使う前にどんな値が入っているのか確認する
* 「==」または「!=」を使って値を調べることができる（このとき開示指定は使わない）

```
var nagano : Int? = Int("1998")
if nagano != nil {
    print("Nagano: \(nagano!)") // ここでは開示指定が必要
}
```

* 開示せずに大小比較することができるが値がnilだった場合、どんな数や文字列よりも小さいという結果が返されるだけで、nillかは分からない

```
var x : Int? = 1964
x > 2000 // falseが返る
x = nil
x < 2000 // trueが返る
```

## 4.2 オプショナル束縛構文

### if-let文

* オプショナル型の式の値がnilでなかった場合、if文のthen節ですぐに使いたい！
* その解決策あります

```
let year : Int? = Int("2020")
if let y = year { // この書き方！
    print("あと\(y - 2014)年")
} else {
    print("エラー")
}
```

* If文の条件にある特殊な構文。if文、while文の条件部にだけ記述可能。
* オプショナル束縛（optional Binding）と呼ぶ（if-let文とも呼ばれる）
* 定数yはif文のthen節の中だけ有効
* 複数個のオプショナル型をif-let文で処理したい場合、if-let文をネストすることができる
* 代入先を変数にしたい場合はvarを記述することができる（letとvarを組み合わせられる）
* 式の評価は左から行われ、最初にnilがあれば以降は評価されない

### オプショナル束縛と条件式

* if-let文の前後に必要に応じて条件式を追加することができる

```
var nagano = 1998
if nagano < 2000, let tokyo = Int("2020"), where tokyo > 2000 {
    print("Tokyo \(tokyo)")
}
```

### guard文

* オプショナル束縛に限定した構文ではないが、想定外の状況が発生した場合にその処理から抜け出す構文

```
let stock = ["01, "2", "q", "X"]
for str in stock {
    guard let v = Int(str) else { // 条件が成立しない場合に実行する
        print(str + "??")
        break
    }
    print(v, terminator:" ")
}
// 1 2 q?? と表示される
```

* else節には必ず実行されるbreakやreturn、throw、制御が戻らないことがわかっている関数やめドッソの呼び出し（12章）を記述しなければならない

### nil合体演算子

* opvがnilでなければopvを開示して利用、nilだったら値Sを利用したいという処理は以下のように書ける

```
(opv != nil) ? opv! : S

nil合体演算子（nil coalescing operator)「??」を利用して簡単に書ける
opv ?? S
```

* nil合体演算子の応用

```
val = Int(str) ?? 0
val = x ?? y ?? z ?? 0
```

### readLine関数

* readline関数をwhile-let文を使って出力する

```
var num = 0
while let line = readLine() {
    print("\(++num) " + line)
}
```

## 4.3 有値オプショナル型

### 有値オプショナル型とは

* プログラムの前後関係から確実にnil以外の値を持っていると判断できる場合に、開示指定をするのが面倒
* オプショナル型のもう１つの形態として、開示指定をしなくても普通の変数のように扱える型を有値オプショナル型（implicy unwrapped optional）と呼ぶ
* 有値オプショナル型は、型宣言で「?」を使わず「!」を使う

```
let year : Int! = Int(“2020”) // 型宣言に ! を使う
print(“あと\(year - 2016)年”) // 開示指定は不要
```

* ただし、値がnilではないと判断するのはあくまでプログラマ
* 有値オプショナル型の変数がnilを持っている場合に使えば実行時エラーが発生する


### オプショナル型と関数

* 関数やメソッドで、オプショナル型や有値オプショナル型を引数とするもの、返り値とするものを定義できる

```
func nickname(name:String?, age:Int) -> String {
    let s = name ?? "名無し"
    return "浪速の" + s "(\(age)歳)"
}

nickname("シンデレラ", age:35) // "浪速のシンデレラ(35歳)"
nickname("シンデレラ", age:20) // "浪速の名無し(20歳)"
```

* オプショナル型の引数には、オプショナル型の値をそのまま指定することもできる

```
var n:String? = "浪速の海賊王"
print( nickname(n, age:25) ) // "浪速の海賊王(25歳)"
n = nil
print( nickname(n, age:25) ) // "浪速の名無し(25歳)"
```

### 関数のinout引数に指定する

* 関数のinout引数の型がオプショナル型だった場合は、変数にそのまま「&」を付けて実引数にできる
* オプショナル型ではない型を持つinout引数に対しても、値がnilではければ、開示指定「!」と「&」を付けて実引数として指定できる

## 4.4 失敗のあるイニシャライザ

### イニシャライザで正しく処理ができない場合

* イニシャライザが正しく処理されない場合に、nilを返す、オプショナル型のイニシャライザを定義することができる
* このイニシャライザを失敗のあるイニシャライザ（failable initializer）と呼ぶ

### 失敗のあるイニシャライザの定義

* 失敗のあるイニシャライザは、initではなく、init?でイニシャライザを定義する
* 初期化が正常にできなかった場合、return nilを実行することで処理を終了できる
* 通常のイニシャライザと失敗のあるイニシャライザが、まったく同じ引数の並びを持つことはできない
* 失敗のあるイニシャライザにはもう１つ、init!という形式があり、初期化した結果として有値オプショナル型を返す（init?で定義した場合と違いがないため実際のAPIではほとんど使われない

## 野澤コラム

* null参照の考案は10億ドル単位の過ち？
http://developers.srad.jp/story/09/03/05/0937219/
